<i18n>
{
	"en": {
		"add-product-group-subscription-type": "Add a product group",
    "product-group-select": "Product group",
    "product-group-delete": "Delete product group",
		"cancel": "Cancel",
    "add-subscription-type": "Add a participant category",
		"empty-product-group-subscription-types-list-error": "The list «Subscription product group» must contain at least 1 element",
    "fifteenth-day-of-the-month": "The 15th day of the month",
		"first-day-of-the-month": "The first day of the month",
    "first-and-fifteenth-day-of-the-month": "The first and 15th day of the month",
		"monthly-payment-moment": "Automatic payment sending",
		"subscription-end-date": "End of payment period",
		"subscription-end-date-error": "The “End date” field must be greater than the “Start date” field",
		"subscription-name": "Name",
    "subscription-name-desc": "<p>These settings will determine the dates on which funds will be automatically added onto cards. (In later steps, you will define expiration dates and the amounts the cards will receive.) Note that subscriptions <b>cannot be modified</b> once they have been assigned to participants!</p>",
		"subscription-name-placeholder": "Ex. Winter 2022",
		"subscription-start-date": "Beginning of payment period",
    "subscription-funds-expiration-date": "Fund expiry date",
    "subscription-funds-expiration-date-error": "The “Fund expiry date” field  must be later than the “End of payment period” field",
    "subscription-type-amount": "Amount",
    "subscription-type-category": "Participant category",
    "subscription-funds-accumulable": "Cumulative funds",
    "previous": "Previous",
    "set-period": "Define the payment period",
    "set-expiration": "Define the expiration date",
    "set-amounts": "Set amounts",
    "subscription-funds-accumulable-disabled": "Disabled",
    "subscription-funds-accumulable-enabled": "Enabled",
    "subscription-funds-accumulable-desc-deactivated": "Whenever scheduled funds are added to cards via this Subscription, the previous funds will expire. (Gift Card amounts, funds from other Subscriptions and funds added manually will not be affected.)",
    "subscription-funds-accumulable-desc-activated": "All of the scheduled funds from this Subscription will expire on the date selected below.",
    "subscription-type-category-must-be-unique": "The “Participant Category” field must be unique within a “Product Group”",
    "subscription-product-group-must-be-unique": "The “Product Group” field must be unique",
    "subscription-payment-based-card-usage": "Payments based on card usage",
    "subscription-payment-based-card-usage-desc-activated": "The card will receive funds on the first possible payment date, but afterwards, it will only receive funds if it has been used since the previous payment date.",
    "subscription-payment-based-card-usage-desc-deactivated": "The card will receive funds at each payment date.",
    "subscription-payment-based-card-usage-enabled": "Enabled",
    "subscription-payment-based-card-usage-disabled": "Disabled",
    "subscription-max-number-of-payments": "Maximum total number of payments",
    "subscription-trigger-fund-expiration": "Funds expiration trigger",
    "subscription-trigger-fund-expiration-desc": "Funds from this subscription will expire at the start of the selected date (12:01 am Eastern Time)",
    "subscription-trigger-fund-expiration-specific-date": "A specific date",
    "subscription-trigger-fund-expiration-number-of-days": "A number of days after the first use",
    "subscription-days-until-funds-expire-after-first-use": "Funds expiry after initial use",
    "subscription-trigger-fund-expiration-number-of-days-desc": "The funds on a card will expire <b>X days after the card is first used</b> for a purchase, or on the <b>Maximum fund expiry date</b>, whichever comes first.",
    "subscription-payment-dates-desc": "<b>Payment dates ({count})</b>: {dates}"
	},
	"fr": {
		"add-product-group-subscription-type": "Ajouter un groupe de produits",
    "product-group-select": "Groupe de produits",
    "product-group-delete": "Supprimer le groupe de produits",
		"cancel": "Annuler",
    "add-subscription-type": "Ajouter une catégorie de participant",
		"empty-product-group-subscription-types-list-error": "La liste «Groupe de produit par abonnement» doit contenir au moins 1 élément",
    "fifteenth-day-of-the-month": "Le 15e jour du mois",
		"first-day-of-the-month": "Le premier jour du mois",
    "first-and-fifteenth-day-of-the-month": "Le premier et le 15e jour du mois",
		"monthly-payment-moment": "Envoi des versements automatiques",
		"subscription-end-date": "Fin période de versements",
		"subscription-end-date-error": "Le champ «Date de fin» doit être ultérieur au champ «Date de début»",
		"subscription-name": "Nom",
    "subscription-name-desc": "<p>Ces paramètres déterminent les dates auxquelles les fonds seront automatiquement ajoutés aux cartes. (Dans les étapes suivantes, vous définirez les dates d'expiration et les montants que les cartes recevront). Notez que les abonnements <b>ne peuvent pas être modifiés</b> une fois qu'ils ont été attribués aux participant-es !</p>",
		"subscription-name-placeholder": "Ex. Hiver 2022",
		"subscription-start-date": "Début période de versements",
		"subscription-type-amount": "Montant",
    "subscription-funds-expiration-date": "Date maximale d’expiration des fonds",
    "subscription-funds-expiration-date-error": "Le champ «Date maximale d’expiration des fonds» doit être ultérieur à la fin de la période de versements.",
    "subscription-type-category": "Catégorie de participant",
    "subscription-funds-accumulable": "Fonds accumulables",
    "previous": "Précédent",
    "set-period": "Définir la période des versements",
    "set-expiration": "Définir les dates d’expiration",
    "set-amounts": "Définir les montants",
    "subscription-funds-accumulable-disabled": "Désactivé",
    "subscription-funds-accumulable-enabled": "Activé",
    "subscription-funds-accumulable-desc-deactivated": "Chaque fois que des fonds programmés sont ajoutés aux cartes à partir de cet Abonnement, les fonds précédents expirent. (Les montants Cartes-Cadeaux, les fonds d'autres Abonnements et les fonds ajoutés manuellement ne seront pas affectés).",
    "subscription-funds-accumulable-desc-activated": "Tous les fonds programmés de cet abonnement expireront à la date sélectionnée ci-dessous.",
    "subscription-type-category-must-be-unique": "Le champ «Catégorie de participant» doit être unique à l'intérieur d'un «Groupe de produits»",
    "subscription-product-group-must-be-unique": "Le champ «Groupe de produits» doit être unique",
    "subscription-payment-based-card-usage": "Versements en fonction de l'utilisation de la carte",
    "subscription-payment-based-card-usage-desc-activated": "La carte recevra des fonds à la première date de versement possible, mais par la suite, elle ne recevra des fonds que si elle a été utilisée depuis la précédente date de versement.",
    "subscription-payment-based-card-usage-desc-deactivated": "La carte recevra des fonds à chaque date de versement.",
    "subscription-payment-based-card-usage-enabled": "Activé",
    "subscription-payment-based-card-usage-disabled": "Désactivé",
    "subscription-max-number-of-payments": "Nombre total maximum de versements",
    "subscription-trigger-fund-expiration": "Déclencheur de l’expiration des fonds",
    "subscription-trigger-fund-expiration-desc": "Les fonds de cet abonnement expireront au début de la date sélectionnée (00h01 heure de l'Est)",
    "subscription-trigger-fund-expiration-specific-date": "Une date spécifique",
    "subscription-trigger-fund-expiration-number-of-days": "Un nombre de jours après la première utilisation",
    "subscription-days-until-funds-expire-after-first-use": "Échéance des fonds après l'usage initial",
    "subscription-trigger-fund-expiration-number-of-days-desc": "Les fonds d'une carte expireront <b>{numberOfDays} jours après la première utilisation de la carte</b> pour un achat, ou à la <b>Date maximale d'expiration des fonds</b>, selon la première éventualité.",
    "subscription-payment-dates-desc":"<b>Dates de versement ({count})</b> : {dates}"
	}
}
</i18n>

<template>
  <Form
    v-slot="{ isSubmitting, errors: formErrors, values, validateField, setFieldValue }"
    :initial-values="initialValues"
    :validation-schema="currentSchema"
    keep-values
    @submit="nextStep">
    <UiStepper
      class="mb-6"
      :step-label="currentStep === 0 ? t('set-period') : currentStep === 1 ? t('set-expiration') : t('set-amounts')"
      :step-count="3"
      :step-number="currentStep + 1" />
    <PfForm
      v-if="currentStep === 0"
      has-footer
      can-cancel
      :disable-submit="Object.keys(formErrors).length > 0"
      :submit-label="t('set-expiration')"
      :cancel-label="t('cancel')"
      :processing="isSubmitting"
      @cancel="closeModal">
      <PfFormSection is-grid>
        <Field v-slot="{ field, errors: fieldErrors }" name="subscriptionName">
          <PfFormInputText
            id="subscriptionName"
            col-span-class="sm:col-span-12"
            v-bind="field"
            :label="t('subscription-name')"
            :placeholder="t('subscription-name-placeholder')"
            :errors="fieldErrors" />
        </Field>
        <!-- eslint-disable vue/no-v-html @intlify/vue-i18n/no-v-html -->
        <div class="flex sm:col-span-12" v-html="t('subscription-name-desc')"></div>
        <Field v-slot="{ field, errors: fieldErrors }" name="startDate">
          <DatePicker
            id="startDate"
            v-bind="field"
            class="sm:col-span-6"
            :label="t('subscription-start-date')"
            :errors="fieldErrors"
            is-inside-modal
            @update:modelValue="forceValidation(values, validateField)" />
        </Field>
        <Field v-slot="{ field, errors: fieldErrors }" name="endDate">
          <DatePicker
            id="endDate"
            v-bind="field"
            class="sm:col-span-6"
            :label="t('subscription-end-date')"
            :errors="fieldErrors"
            is-inside-modal
            @update:modelValue="forceValidation(values, validateField)" />
        </Field>
        <div class="flex flex-col sm:col-span-12">
          <span
            v-if="getSubscriptionPaymentDates.length > 0"
            class="text-sm text-grey-500 dark:text-grey-400"
            v-html="
              t('subscription-payment-dates-desc', {
                count: getSubscriptionPaymentDates.length,
                dates: getSubscriptionPaymentDates.join(', ')
              })
            "></span>
          <span
            v-else
            class="text-sm text-grey-500 dark:text-grey-400"
            v-html="t('subscription-payment-dates-desc', { count: '-', dates: '-' })"></span>
        </div>
        <Field name="isSubscriptionPaymentBasedCardUsage">
          <div class="flex flex-col sm:col-span-12 mb-0">
            <div class="flex flex-row">
              <span class="text-sm font-medium text-grey-900 dark:text-grey-200">{{
                t("subscription-payment-based-card-usage")
              }}</span>
              <UiSwitch
                id="isSubscriptionPaymentBasedCardUsage"
                v-model="subscriptionPaymentBasedCardUsageValue"
                class="mx-auto mr-0"
                @update:modelValue="(e) => updateIsSubscriptionPaymentBasedCardUsage(setFieldValue, validateField, e)">
                <template #left>
                  <span class="mr-2 text-p3 font-semibold">{{
                    subscriptionPaymentBasedCardUsageValue
                      ? t("subscription-payment-based-card-usage-enabled")
                      : t("subscription-payment-based-card-usage-disabled")
                  }}</span>
                </template>
              </UiSwitch>
            </div>
            <div class="flex sm:col-span-12">
              <!-- eslint-disable vue/no-v-html @intlify/vue-i18n/no-v-html -->
              <span
                v-if="!subscriptionPaymentBasedCardUsageValue"
                class="text-sm text-grey-500 dark:text-grey-400"
                v-html="t('subscription-payment-based-card-usage-desc-deactivated')"></span>
              <span
                v-else
                class="text-sm text-grey-500 dark:text-grey-400"
                v-html="t('subscription-payment-based-card-usage-desc-activated')"></span>
              <!-- eslint-enable vue/no-v-html @intlify/vue-i18n/no-v-html -->
            </div>
          </div>
        </Field>
        <Field v-slot="{ errors: fieldErrors }" name="monthlyPaymentMoment">
          <PfFormInputSelect
            id="monthlyPaymentMoment"
            class="sm:col-span-6"
            :value="monthlyPaymentMomentValue"
            :label="t('monthly-payment-moment')"
            :options="monthlyPaymentMomentOptions"
            :errors="fieldErrors"
            @input="(e) => updateMonthlyPaymentMoment(setFieldValue, validateField, e)" />
        </Field>
        <Field v-slot="{ field, errors: fieldErrors }" name="maxNumberOfPayments">
          <PfFormInputText
            id="maxNumberOfPayments"
            class="sm:col-span-6"
            v-bind="field"
            :label="t('subscription-max-number-of-payments')"
            :errors="fieldErrors"
            input-type="number"
            min="0"
            :disabled="!subscriptionPaymentBasedCardUsageValue">
          </PfFormInputText>
        </Field>
      </PfFormSection>
    </PfForm>

    <PfForm
      v-if="currentStep === 1"
      has-footer
      can-cancel
      :disable-submit="Object.keys(formErrors).length > 0"
      :submit-label="t('set-amounts')"
      :cancel-label="t('previous')"
      :processing="isSubmitting"
      @cancel="prevStep">
      <PfFormSection is-grid>
        <Field name="isFundsAccumulable">
          <div class="flex flex-col sm:col-span-12 mb-0">
            <div class="flex flex-row">
              <span class="text-sm font-medium text-grey-900 dark:text-grey-200">{{ t("subscription-funds-accumulable") }}</span>
              <UiSwitch
                id="isFundsAccumulable"
                v-model="isFundsAccumulableValue"
                class="mx-auto mr-0"
                @update:modelValue="(e) => updateIsFundsAccumulable(setFieldValue, validateField)">
                <template #left>
                  <span class="mr-2 text-p3 font-semibold">{{
                    isFundsAccumulableValue
                      ? t("subscription-funds-accumulable-enabled")
                      : t("subscription-funds-accumulable-disabled")
                  }}</span>
                </template>
              </UiSwitch>
            </div>
            <div class="flex sm:col-span-12">
              <!-- eslint-disable vue/no-v-html @intlify/vue-i18n/no-v-html -->
              <span
                v-if="!isFundsAccumulableValue"
                class="text-sm text-grey-500 dark:text-grey-400"
                v-html="t('subscription-funds-accumulable-desc-deactivated')"></span>
              <span
                v-else
                class="text-sm text-grey-500 dark:text-grey-400"
                v-html="t('subscription-funds-accumulable-desc-activated')"></span>
              <!-- eslint-enable vue/no-v-html @intlify/vue-i18n/no-v-html -->
            </div>
          </div>
        </Field>
        <Field name="triggerFundExpiration">
          <PfFormInputSelect
            id="triggerFundExpiration"
            class="sm:col-span-12"
            :value="triggerFundExpirationValue"
            :label="t('subscription-trigger-fund-expiration')"
            :options="triggerFundExpirationOptions"
            :description="t('subscription-trigger-fund-expiration-desc')"
            @input="(e) => updateTriggerFundExpirationValue(setFieldValue, validateField, e)" />
        </Field>
        <div v-if="triggerFundExpirationValue === NUMBER_OF_DAYS" class="flex sm:col-span-12">
          <!-- eslint-disable vue/no-v-html @intlify/vue-i18n/no-v-html -->
          <span
            class="text-sm text-grey-500 dark:text-grey-400"
            v-html="
              t('subscription-trigger-fund-expiration-number-of-days-desc', {
                numberOfDays:
                  numberDaysUntilFundsExpire !== '' && numberDaysUntilFundsExpire !== null ? numberDaysUntilFundsExpire : '-'
              })
            "></span>
          <!-- eslint-enable vue/no-v-html @intlify/vue-i18n/no-v-html -->
        </div>
        <Field v-slot="{ field: inputField, errors: fieldErrors }" v-model="fundsExpirationDateValue" name="fundsExpirationDate">
          <DatePicker
            id="fundsExpirationDate"
            class="sm:col-span-6"
            v-bind="inputField"
            :label="t('subscription-funds-expiration-date')"
            :errors="isFundsAccumulableValue ? fieldErrors : []"
            :disabled="!isFundsAccumulableValue"
            is-inside-modal
            @update:modelValue="forceValidation(values, validateField)" />
        </Field>
        <Field v-slot="{ errors: fieldErrors }" name="numberDaysUntilFundsExpire">
          <PfFormInputText
            id="numberDaysUntilFundsExpire"
            class="sm:col-span-6"
            :value="numberDaysUntilFundsExpire"
            :label="t('subscription-days-until-funds-expire-after-first-use')"
            :errors="fieldErrors"
            input-type="number"
            min="0"
            :disabled="triggerFundExpirationValue !== NUMBER_OF_DAYS"
            @input="(e) => updateNumberDaysUntilFundsExpireValue(setFieldValue, validateField, e)">
          </PfFormInputText>
        </Field>
      </PfFormSection>
    </PfForm>

    <PfForm
      v-if="currentStep === 2"
      has-footer
      can-cancel
      :disable-submit="Object.keys(formErrors).length > 0"
      :submit-label="props.submitBtn"
      :cancel-label="t('previous')"
      :processing="isSubmitting"
      @cancel="prevStep">
      <PfFormSection>
        <FieldArray v-slot="{ fields, remove, push }" key-path="id" name="productGroupSubscriptionTypes">
          <UiFieldArray
            :block-layout="true"
            :fields="fields"
            :add-label="t('add-product-group-subscription-type')"
            :delete-label="t('product-group-delete')"
            :empty-list-error="t('empty-product-group-subscription-types-list-error')"
            :errors="formErrors[`productGroupSubscriptionTypes`]"
            @addField="() => createNewProductGroupSubscriptionTypes(push)"
            @removeField="(idx) => remove(idx)">
            <template #default="slotProps">
              <div class="sm:col-span-12 space-y-6 divide-y divide-grey-100">
                <Field
                  v-slot="{ field, errors: fieldErrors }"
                  :name="`productGroupSubscriptionTypes[${slotProps.idx}].productGroupId`">
                  <PfFormInputSelect
                    :key="`productGroupSubscriptionTypes[${slotProps.idx}].productGroupId`"
                    v-bind="field"
                    :label="t('product-group-select')"
                    :options="productGroups"
                    :errors="fieldErrors" />
                </Field>
                <FieldArray
                  v-slot="{ fields: fieldsChild, remove: removeChild, push: pushChild }"
                  key-path="id"
                  :name="`productGroupSubscriptionTypes[${slotProps.idx}].types`">
                  <UiFieldArray
                    class="pt-3"
                    :is-inside-block-layout="true"
                    :fields="fieldsChild"
                    :add-label="t('add-subscription-type')"
                    :empty-list-error="t('empty-product-group-subscription-types-list-error')"
                    :errors="formErrors[`productGroupSubscriptionTypes[${slotProps.idx}].types`]"
                    @addField="() => pushChild({ amount: '', type: '' })"
                    @removeField="(idx) => removeChild(idx)">
                    <template #default="slotPropsType">
                      <Field
                        v-slot="{ field: inputField, errors: fieldErrors }"
                        :name="`productGroupSubscriptionTypes[${slotProps.idx}].types[${slotPropsType.idx}].type`">
                        <PfFormInputSelect
                          :id="`productGroupSubscriptionTypes[${slotProps.idx}].types[${slotPropsType.idx}].type`"
                          class="grow"
                          v-bind="inputField"
                          :label="t('subscription-type-category')"
                          :options="beneficiaryTypes"
                          :errors="fieldErrors"
                          col-span-class="sm:col-span-6" />
                      </Field>
                      <Field
                        v-slot="{ field: inputField, errors: fieldErrors }"
                        :name="`productGroupSubscriptionTypes[${slotProps.idx}].types[${slotPropsType.idx}].amount`">
                        <PfFormInputText
                          :id="`productGroupSubscriptionTypes[${slotProps.idx}].types[${slotPropsType.idx}].amount`"
                          v-bind="inputField"
                          :label="t('subscription-type-amount')"
                          :errors="fieldErrors"
                          input-type="number"
                          min="0"
                          col-span-class="sm:col-span-6">
                          <template #trailingIcon>
                            <UiDollarSign :errors="fieldErrors" />
                          </template>
                        </PfFormInputText>
                      </Field>
                    </template>
                  </UiFieldArray>
                </FieldArray>
              </div>
            </template>
          </UiFieldArray>
        </FieldArray>
      </PfFormSection>
    </PfForm>
  </Form>
</template>

<script setup>
import gql from "graphql-tag";
import { useI18n } from "vue-i18n";
import { defineEmits, defineProps, computed, ref } from "vue";
import { FieldArray } from "vee-validate";
import { string, object, array, mixed, lazy, number } from "yup";
import { useQuery, useResult } from "@vue/apollo-composable";

import { PRODUCT_GROUP_LOYALTY } from "@/lib/consts/enums";
import {
  FIRST_DAY_OF_THE_MONTH,
  FIFTEENTH_DAY_OF_THE_MONTH,
  FIRST_AND_FIFTEENTH_DAY_OF_THE_MONTH
} from "@/lib/consts/monthly-payment-moment";
import { SPECIFIC_DATE, NUMBER_OF_DAYS } from "@/lib/consts/funds-expiration-trigger";
import { formatDate, textualFormat } from "@/lib/helpers/date";

import DatePicker from "@/components/ui/date-picker.vue";

const { t } = useI18n();
const currentStep = ref(0);

const emit = defineEmits(["submit", "closeModal"]);
const props = defineProps({
  title: {
    type: String,
    default: ""
  },
  submitBtn: {
    type: String,
    default: ""
  },
  subscriptionName: {
    type: String,
    default: ""
  },
  isFundsAccumulable: {
    type: Boolean,
    default: true
  },
  subscriptionPaymentBasedCardUsage: {
    type: Boolean,
    default: false
  },
  monthlyPaymentMoment: {
    type: String,
    default: FIRST_DAY_OF_THE_MONTH
  },
  triggerFundExpiration: {
    type: String,
    default: SPECIFIC_DATE
  },
  maxNumberOfPayments: {
    type: Number,
    default: null
  },
  numberDaysUntilFundsExpire: {
    type: Number,
    default: null
  },
  fundsExpirationDate: {
    type: Date,
    default: null
  },
  startDate: {
    type: Date,
    default: null
  },
  endDate: {
    type: Date,
    default: null
  },
  productGroupSubscriptionTypes: {
    type: Array,
    default() {
      return [{ productGroupId: "", types: [{ amount: "", type: "" }] }];
    }
  },
  projectId: {
    type: String,
    required: true
  }
});

const initialValues = {
  subscriptionName: props.subscriptionName,
  monthlyPaymentMoment: props.monthlyPaymentMoment,
  startDate: props.startDate,
  endDate: props.endDate,
  productGroupSubscriptionTypes: props.productGroupSubscriptionTypes,
  maxNumberOfPayments: props.maxNumberOfPayments,
  numberDaysUntilFundsExpire: props.numberDaysUntilFundsExpire
};

const isFundsAccumulableValue = ref(props.isFundsAccumulable);
const fundsExpirationDateValue = ref(props.fundsExpirationDate);
const subscriptionPaymentBasedCardUsageValue = ref(props.subscriptionPaymentBasedCardUsage);
const startDateValue = ref(props.startDate);
const endDateValue = ref(props.endDate);
const triggerFundExpirationValue = ref(props.triggerFundExpiration);
const monthlyPaymentMomentValue = ref(props.monthlyPaymentMoment);
const numberDaysUntilFundsExpire = ref(props.numberDaysUntilFundsExpire);

const monthlyPaymentMomentOptions = [
  {
    label: t("first-day-of-the-month"),
    value: FIRST_DAY_OF_THE_MONTH
  },
  {
    label: t("fifteenth-day-of-the-month"),
    value: FIFTEENTH_DAY_OF_THE_MONTH
  },
  {
    label: t("first-and-fifteenth-day-of-the-month"),
    value: FIRST_AND_FIFTEENTH_DAY_OF_THE_MONTH
  }
];

const triggerFundExpirationOptions = [
  {
    label: t("subscription-trigger-fund-expiration-specific-date"),
    value: SPECIFIC_DATE
  },
  {
    label: t("subscription-trigger-fund-expiration-number-of-days"),
    value: NUMBER_OF_DAYS
  }
];

const { result } = useQuery(
  gql`
    query Project($id: ID!) {
      project(id: $id) {
        id
        beneficiaryTypes {
          id
          name
        }
        productGroups {
          id
          name
          color
          orderOfAppearance
        }
      }
    }
  `,
  {
    id: props.projectId
  }
);
const beneficiaryTypes = useResult(result, null, (data) => {
  return data.project.beneficiaryTypes.map((x) => ({ label: x.name, value: x.id }));
});

const productGroups = useResult(result, null, (data) => {
  return data.project.productGroups.filter((x) => x.name !== PRODUCT_GROUP_LOYALTY).map((x) => ({ label: x.name, value: x.id }));
});

// Form validation & steps management
const validationSchemas = computed(() => {
  return [
    object({
      subscriptionName: string().label(t("subscription-name")).required(),
      startDate: mixed().label(t("subscription-start-date")).required(),
      endDate: mixed()
        .label(t("subscription-end-date"))
        .test({
          name: "sameValue",
          exclusive: false,
          params: {},
          message: t("subscription-end-date-error"),
          test: function (value, form) {
            return new Date(value) > new Date(form.parent.startDate);
          }
        })
        .required(),
      maxNumberOfPayments: lazy(() => {
        if (subscriptionPaymentBasedCardUsageValue.value) {
          return number()
            .transform((_, value) => {
              if (value === null) return 0;
              return +value.toString().replace(/,/, ".");
            })
            .label(t("subscription-max-number-of-payments"))
            .min(1)
            .required();
        } else {
          return mixed().test({
            test: function () {
              return true;
            }
          });
        }
      })
    }),
    object({
      fundsExpirationDate: lazy(() => {
        if (isFundsAccumulableValue.value) {
          return mixed()
            .label(t("subscription-funds-expiration-date"))
            .test({
              name: "sameValue",
              exclusive: false,
              params: {},
              message: t("subscription-funds-expiration-date-error"),
              test: function (value, form) {
                return new Date(value) > new Date(form.parent.endDate);
              }
            })
            .required();
        } else {
          return mixed().test({
            test: function () {
              return true;
            }
          });
        }
      }),
      numberDaysUntilFundsExpire: lazy(() => {
        if (triggerFundExpirationValue.value === NUMBER_OF_DAYS) {
          return number()
            .transform((_, value) => {
              if (value === null) return 0;
              return +value.toString().replace(/,/, ".");
            })
            .label(t("subscription-days-until-funds-expire-after-first-use"))
            .min(1)
            .required();
        } else {
          return mixed().test({
            test: function () {
              return true;
            }
          });
        }
      })
    }),
    object({
      productGroupSubscriptionTypes: array()
        .label(t("product-group-select"))
        .min(1)
        .of(
          object({
            productGroupId: string().label(t("product-group-select")).required(),
            types: array()
              .label(t("subscription-type-category"))
              .min(1)
              .of(
                object({
                  amount: string().label(t("subscription-type-amount")).required(),
                  type: string().label(t("subscription-type-category")).required()
                })
              )
              .unique(t("subscription-type-category-must-be-unique"), (a) => a.type)
          })
        )
        .unique(t("subscription-product-group-must-be-unique"), (a) => a.productGroupId)
    })
  ];
});

const currentSchema = computed(() => {
  return validationSchemas.value[currentStep.value];
});

const getSubscriptionPaymentDates = computed(() => {
  const dates = [];

  if (startDateValue.value && endDateValue.value) {
    const startMonth =
      (monthlyPaymentMomentValue.value === FIRST_DAY_OF_THE_MONTH && startDateValue.value.getDate() === 1) ||
      (monthlyPaymentMomentValue.value === FIRST_AND_FIFTEENTH_DAY_OF_THE_MONTH && startDateValue.value.getDate() <= 15) ||
      (monthlyPaymentMomentValue.value === FIFTEENTH_DAY_OF_THE_MONTH && startDateValue.value.getDate() <= 15)
        ? startDateValue.value.getMonth()
        : startDateValue.value.getMonth() + 1;
    let currentDate = new Date(
      startDateValue.value.getFullYear(),
      startMonth,
      monthlyPaymentMomentValue.value === FIFTEENTH_DAY_OF_THE_MONTH ||
      (monthlyPaymentMomentValue.value === FIRST_AND_FIFTEENTH_DAY_OF_THE_MONTH && startDateValue.value.getDate() <= 15)
        ? 15
        : 1
    );

    while (currentDate <= endDateValue.value) {
      dates.push(new Date(currentDate));
      if (
        monthlyPaymentMomentValue.value === FIRST_DAY_OF_THE_MONTH ||
        monthlyPaymentMomentValue.value === FIFTEENTH_DAY_OF_THE_MONTH
      ) {
        currentDate = new Date(currentDate.setMonth(currentDate.getMonth() + 1));
      } else if (currentDate.getDate() === 1) {
        currentDate = new Date(currentDate.setDate(15));
      } else {
        currentDate = new Date(currentDate.setDate(1));
        currentDate = new Date(currentDate.setMonth(currentDate.getMonth() + 1));
      }
    }
  }

  return dates.map((x) => formatDate(x, textualFormat));
});

function createNewProductGroupSubscriptionTypes(push) {
  push({ productGroupId: "", types: [{ amount: "", type: "" }] });
}

function nextStep(values) {
  if (currentStep.value === 2) {
    onSubmit(values);
    return;
  }
  currentStep.value++;
}

function prevStep() {
  if (currentStep.value <= 0) {
    return;
  }

  currentStep.value--;
}

function closeModal() {
  emit("closeModal");
}

async function onSubmit({
  subscriptionName,
  startDate,
  endDate,
  monthlyPaymentMoment,
  maxNumberOfPayments,
  fundsExpirationDate,
  productGroupSubscriptionTypes
}) {
  emit("submit", {
    subscriptionName,
    startDate,
    endDate,
    monthlyPaymentMoment,
    isSubscriptionPaymentBasedCardUsage: subscriptionPaymentBasedCardUsageValue.value,
    maxNumberOfPayments: subscriptionPaymentBasedCardUsageValue.value ? parseInt(maxNumberOfPayments) : null,
    isFundsAccumulable: isFundsAccumulableValue.value,
    fundsExpirationDate,
    triggerFundExpiration: triggerFundExpirationValue.value,
    numberDaysUntilFundsExpire:
      triggerFundExpirationValue.value === NUMBER_OF_DAYS ? parseInt(numberDaysUntilFundsExpire.value) : null,
    productGroupSubscriptionTypes
  });
}

function updateIsFundsAccumulable(setFieldValue, validateField) {
  if (!isFundsAccumulableValue.value) {
    setFieldValue("fundsExpirationDate", null);
    fundsExpirationDateValue.value = null;
    validateField("fundsExpirationDate");
  }
}

function updateIsSubscriptionPaymentBasedCardUsage(setFieldValue, validateField, value) {
  if (!value) {
    setFieldValue("maxNumberOfPayments", null);
    validateField("maxNumberOfPayments");
  }
  if (!subscriptionPaymentBasedCardUsageValue.value) {
    setFieldValue("subscriptionPaymentBasedCardUsage", null);
    subscriptionPaymentBasedCardUsageValue.value = null;
    validateField("subscriptionPaymentBasedCardUsage");
  }
}

function updateTriggerFundExpirationValue(setFieldValue, validateField, value) {
  triggerFundExpirationValue.value = value;
  if (value === SPECIFIC_DATE) {
    setFieldValue("numberDaysUntilFundsExpire", null);
    validateField("numberDaysUntilFundsExpire");
  }
}

function updateMonthlyPaymentMoment(setFieldValue, validateField, value) {
  monthlyPaymentMomentValue.value = value;
  if (value === FIRST_DAY_OF_THE_MONTH || value === FIRST_AND_FIFTEENTH_DAY_OF_THE_MONTH) {
    setFieldValue("monthlyPaymentMoment", value);
    validateField("monthlyPaymentMoment");
  }
}

function updateNumberDaysUntilFundsExpireValue(setFieldValue, validateField, value) {
  numberDaysUntilFundsExpire.value = value;
  setFieldValue("numberDaysUntilFundsExpire", value);
  validateField("numberDaysUntilFundsExpire");
}

async function forceValidation(values, validateField) {
  if (values.endDate) {
    endDateValue.value = values.endDate;
    validateField("endDate");
  }
  if (values.startDate) {
    startDateValue.value = values.startDate;
    validateField("startDate");
  }
  if (values.fundsExpirationDate) {
    validateField("fundsExpirationDate");
  }
  if (values.subscriptionPaymentBasedCardUsage) {
    validateField("subscriptionPaymentBasedCardUsage");
  }
  if (values.triggerFundExpiration) {
    validateField("triggerFundExpiration");
  }
}
</script>
